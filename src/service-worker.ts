/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = `ignitegigs-cache-${version}`;
const OFFLINE_URL = '/offline.html';

// Assets generated by the build process + static files
const ASSETS = [...build, ...files];

// Install: cache all static assets and the offline page
self.addEventListener('install', (event: ExtendableEvent) => {
	event.waitUntil(
		caches.open(CACHE_NAME).then(async (cache) => {
			await cache.addAll(ASSETS);
			// Cache the offline fallback page separately in case it's already in ASSETS
			await cache.add(new Request(OFFLINE_URL));
		})
	);
	// Activate immediately without waiting for existing clients to close
	self.skipWaiting();
});

// Activate: clean up old caches
self.addEventListener('activate', (event: ExtendableEvent) => {
	event.waitUntil(
		caches.keys().then((keys) => {
			return Promise.all(
				keys
					.filter((key) => key !== CACHE_NAME)
					.map((key) => caches.delete(key))
			);
		})
	);
	// Take control of all open clients immediately
	self.clients.claim();
});

// Fetch: cache-first for static assets, network-first for everything else
self.addEventListener('fetch', (event: FetchEvent) => {
	const { request } = event;

	// Ignore non-GET requests
	if (request.method !== 'GET') return;

	// Ignore chrome-extension and other non-http(s) requests
	const url = new URL(request.url);
	if (!url.protocol.startsWith('http')) return;

	// Cache-first for static assets (build artifacts and static files)
	if (ASSETS.includes(url.pathname)) {
		event.respondWith(
			caches.match(request).then((cached) => {
				return cached || fetch(request);
			})
		);
		return;
	}

	// Network-first for API calls and page navigations
	event.respondWith(
		fetch(request)
			.then((response) => {
				// Only cache successful responses
				if (response.ok && response.type === 'basic') {
					const clone = response.clone();
					caches.open(CACHE_NAME).then((cache) => {
						cache.put(request, clone);
					});
				}
				return response;
			})
			.catch(async () => {
				// Try to serve from cache
				const cached = await caches.match(request);
				if (cached) return cached;

				// For navigation requests, serve the offline page
				if (request.mode === 'navigate') {
					const offlinePage = await caches.match(OFFLINE_URL);
					if (offlinePage) return offlinePage;
				}

				return new Response('Offline', {
					status: 503,
					statusText: 'Service Unavailable'
				});
			})
	);
});
